#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Shioaji ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÂô® - Â∞àÈñÄÊî∂ÈõÜ5ÂàÜÈêòKÁ∑öË≥áÊñô (Êõ¥Êñ∞Âà∞2025-07-08)
"""
import sys
import os
import time
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import pandas as pd

# Ê∑ªÂä†Ë∑ØÂæë
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))
sys.path.insert(0, str(current_dir / "data_pipeline"))
sys.path.insert(0, str(current_dir / "market_data_collector"))

# Ë®≠ÂÆöÊó•Ë™å
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ShioajiFlowMonitor:
    """Shioaji API ÊµÅÈáèÁõ£ÊéßÂô® - ‰ΩøÁî®ÂÆòÊñπ api.usage() ÊñπÊ≥ï"""
    
    def __init__(self, api=None):
        self.api = api
        self.last_usage = None
    
    def set_api(self, api):
        """Ë®≠ÂÆö API ÂØ¶‰æã"""
        self.api = api
    
    def get_usage_status(self):
        """Áç≤Âèñ API ‰ΩøÁî®ÁãÄÊ≥Å"""
        if not self.api:
            logger.debug("API Áâ©‰ª∂ÁÇ∫ NoneÔºåÁÑ°Ê≥ïÁç≤Âèñ‰ΩøÁî®ÁãÄÊ≥Å")
            return None
        
        try:
            # Ê™¢Êü• API ÊòØÂê¶ÈÇÑÊúâÊïà
            if not hasattr(self.api, 'usage'):
                logger.warning("‚ö†Ô∏è API Áâ©‰ª∂Ê≤íÊúâ usage ÊñπÊ≥ï")
                return None
            
            # ‰ΩøÁî®ÂÆòÊñπ api.usage() ÊñπÊ≥ï
            usage_status = self.api.usage()
            self.last_usage = usage_status
            return usage_status
        except AttributeError as e:
            logger.warning(f"‚ö†Ô∏è API Áâ©‰ª∂Â±¨ÊÄßÈåØË™§: {e}")
            return None
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÁÑ°Ê≥ïÁç≤Âèñ API ‰ΩøÁî®ÁãÄÊ≥Å: {e}")
            return None
    
    def show_status(self):
        """È°ØÁ§∫‰ΩøÁî®ÁãÄÊ≥Å"""
        usage_status = self.get_usage_status()
        
        if usage_status:
            try:
                # Ëß£Êûê UsageStatus
                connections = getattr(usage_status, 'connections', 0)
                bytes_used = getattr(usage_status, 'bytes', 0)
                limit_bytes = getattr(usage_status, 'limit_bytes', 0)
                remaining_bytes = getattr(usage_status, 'remaining_bytes', 0)
                
                # ËΩâÊèõÁÇ∫ MB
                bytes_used_mb = bytes_used / (1024 * 1024)
                limit_mb = limit_bytes / (1024 * 1024)
                remaining_mb = remaining_bytes / (1024 * 1024)
                
                # Ë®àÁÆó‰ΩøÁî®ÁôæÂàÜÊØî
                if limit_bytes > 0:
                    percentage = (bytes_used / limit_bytes) * 100
                else:
                    percentage = 0
                
                logger.info("=" * 40)
                logger.info(f"üìä Shioaji API ÊµÅÈáèÁãÄÊ≥Å")
                logger.info("=" * 40)
                logger.info(f"üîó ÈÄ£Á∑öÊï∏: {connections}")
                logger.info(f"üìà Â∑≤‰ΩøÁî®: {bytes_used_mb:.1f} MB")
                logger.info(f"üìä Á∏ΩÈôêÂà∂: {limit_mb:.1f} MB")
                logger.info(f"üíæ Ââ©È§ò: {remaining_mb:.1f} MB")
                logger.info(f"‚ö° ‰ΩøÁî®Áéá: {percentage:.1f}%")
                logger.info("=" * 40)
                
                # Ë≠¶ÂëäÊ™¢Êü•
                if percentage > 85:
                    logger.warning(f"‚ö†Ô∏è ÊµÅÈáè‰ΩøÁî®ÁéáÂ∑≤ÈÅî {percentage:.1f}%ÔºåÊé•ËøëÈôêÂà∂ÔºÅ")
                elif percentage > 90:
                    logger.error(f"üö® ÊµÅÈáè‰ΩøÁî®ÁéáÂ∑≤ÈÅî {percentage:.1f}%ÔºåÂç≥Â∞áÈÅîÂà∞ÈôêÂà∂ÔºÅ")
                
                return {
                    'connections': connections,
                    'bytes_used': bytes_used,
                    'limit_bytes': limit_bytes,
                    'remaining_bytes': remaining_bytes,
                    'percentage': percentage
                }
                
            except Exception as e:
                logger.error(f"‚ùå Ëß£Êûê UsageStatus Â§±Êïó: {e}")
                logger.info(f"üìä ÂéüÂßã UsageStatus: {usage_status}")
                return None
        else:
            logger.info("üìä Shioaji API ÊµÅÈáèÁãÄÊ≥Å: ÁÑ°Ê≥ïÁç≤ÂèñÔºàAPI ÂèØËÉΩÂ∑≤ÁôªÂá∫Ôºâ")
            return None
    
    def check_flow_limit(self, threshold_percentage: float = 95.0) -> bool:
        """Ê™¢Êü•ÊòØÂê¶Êé•ËøëÊµÅÈáèÈôêÂà∂"""
        usage_status = self.get_usage_status()
        
        if usage_status:
            try:
                bytes_used = getattr(usage_status, 'bytes', 0)
                limit_bytes = getattr(usage_status, 'limit_bytes', 0)
                
                if limit_bytes > 0:
                    percentage = (bytes_used / limit_bytes) * 100
                    return percentage >= threshold_percentage
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Ê™¢Êü•ÊµÅÈáèÈôêÂà∂Â§±Êïó: {e}")
        
        return False

class ShioajiDataCollector:
    """Shioaji ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÂô®"""
    
    def __init__(self):
        self.api = None
        self.flow_monitor = None
        
        # ÂåØÂÖ•ÂøÖË¶ÅÊ®°ÁµÑ
        try:
            from market_data_collector.utils.db import insert_df, query_df
            from market_data_collector.utils.config import (
                SHIOAJI_USER, SHIOAJI_PASS, SHIOAJI_CA_PATH, SHIOAJI_CA_PASS, SHIOAJI_SIMULATION
            )
            
            self.insert_df = insert_df
            self.query_df = query_df
            self.shioaji_config = {
                'user': SHIOAJI_USER,
                'pass': SHIOAJI_PASS,
                'ca_path': SHIOAJI_CA_PATH,
                'ca_pass': SHIOAJI_CA_PASS,
                'simulation': SHIOAJI_SIMULATION
            }
            
            # ÂòóË©¶ÂåØÂÖ• data_fetcherÔºåÂ¶ÇÊûúÂ§±ÊïóÂâáË∑≥ÈÅéË≥áÊñôË°®Âª∫Á´ã
            try:
                from market_data_collector.utils.data_fetcher import create_db_and_table
                
                # Á¢∫‰øùË≥áÊñôË°®Â∑≤Âª∫Á´ã (ÂåÖÂê´ candlesticks_min)
                if not hasattr(self, '_tables_created'):
                    logger.info("üîß Âª∫Á´ãË≥áÊñôË°® (ÂåÖÂê´ candlesticks_min)...")
                    create_db_and_table()
                    logger.info("‚úÖ Ë≥áÊñôË°®Âª∫Á´ãÂÆåÊàê")
                    self._tables_created = True
                    
            except ImportError as e:
                logger.warning(f"‚ö†Ô∏è ÁÑ°Ê≥ïÂåØÂÖ• data_fetcher: {e}")
                logger.warning("‚ö†Ô∏è Ë∑≥ÈÅéË≥áÊñôË°®Âª∫Á´ãÔºåË´ãÁ¢∫‰øùË≥áÊñôË°®Â∑≤Â≠òÂú®")
                
        except ImportError as e:
            logger.error(f"ÁÑ°Ê≥ïÂåØÂÖ•ÂøÖË¶ÅÊ®°ÁµÑ: {e}")
            raise
    
    def login_shioaji(self):
        """ÁôªÂÖ• Shioaji API"""
        try:
            import shioaji as sj
            
            logger.info("üîê Ê≠£Âú®ÁôªÂÖ• Shioaji API...")
            
            # Âª∫Á´ãAPIÈÄ£Á∑ö
            self.api = sj.Shioaji(simulation=self.shioaji_config['simulation'])
            
            # ÁôªÂÖ• (Ë®≠ÂÆö fetch_contract=False ÁØÄÁúÅÊµÅÈáè)
            self.api.login(
                self.shioaji_config['user'],
                self.shioaji_config['pass'],
                fetch_contract=False
            )
            
            logger.info("üí° Â∑≤Ë®≠ÂÆö fetch_contract=False ‰ª•ÁØÄÁúÅÊµÅÈáè")
            
            # ÂïüÁî®ÊÜëË≠â
            self.api.activate_ca(
                ca_path=self.shioaji_config['ca_path'],
                ca_passwd=self.shioaji_config['ca_pass'],
                person_id=self.shioaji_config['user']
            )
            
            logger.info("‚úÖ Shioaji ÁôªÂÖ•ÊàêÂäü")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Shioaji ÁôªÂÖ•Â§±Êïó: {e}")
            return False
    
    def setup_flow_monitor(self):
        """Ë®≠ÂÆöÊµÅÈáèÁõ£Êéß"""
        try:
            # ‰ΩøÁî®Êñ∞ÁöÑ Shioaji ÊµÅÈáèÁõ£ÊéßÂô®
            self.flow_monitor = ShioajiFlowMonitor(self.api)
            logger.info("üìä Shioaji ÊµÅÈáèÁõ£ÊéßÂô®Â∑≤ÂïüÂãï")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è ÊµÅÈáèÁõ£ÊéßÂô®ÂïüÂãïÂ§±Êïó: {e}")
            self.flow_monitor = None
    
    def get_stock_list(self) -> List[str]:
        """Áç≤ÂèñËÇ°Á•®Ê∏ÖÂñÆ - 180ÊîØËÇ°Á•®"""
        # ‰ΩøÁî®ÂÆåÊï¥ÁöÑ180ÊîØËÇ°Á•®Ê∏ÖÂñÆ
        group_A = [
            "2330","2317","2454","2303","2408","2412","2382","2357","2379","3034",
            "3008","4938","2449","2383","2356","3006","3661","2324","8046","3017",
            "6121","3037","3014","3035","3062","3030","3529","5443","2337","8150",
            "3293","3596","2344","2428","2345","2338","6202","5347","3673","3105",
            "6231","6669","4961","4967","6668","4960","3528","6147","3526","6547",
            "8047","3227","4968","5274","6415","6414","6770","2331","6290","2342"
        ]
        
        group_B = [
            "2603","2609","2615","2610","2618","2637","2606","2002","2014","2027",
            "2201","1201","1216","1301","1303","1326","1710","1717","1722","1723",
            "1402","1409","1434","1476","2006","2049","2105","2106","2107","1605",
            "1609","1608","1612","2308","1727","1730","1101","1102","1108","1210",
            "1215","1802","1806","1810","1104","1313","1314","1310","5608","5607",
            "8105","8940","5534","5609","5603","2023","2028","2114","9933","2501"
        ]
        
        group_C = [
            "2880","2881","2882","2883","2884","2885","2886","2887","2888","2890",
            "2891","2892","2812","3665","2834","2850","2801","2836","2845","4807",
            "3702","3706","4560","8478","4142","4133","6525","6548","6843","1513",
            "1514","1516","1521","1522","1524","1533","1708","3019","5904","5906",
            "5902","6505","6806","6510","2207","2204","2231","1736","4105","4108",
            "4162","1909","1702","9917","1217","1218","1737","1783","3708","1795"
        ]
        
        all_stocks = group_A + group_B + group_C
        all_stocks = list(set(all_stocks))  # ÂéªÈáç
        all_stocks.sort()
        
        logger.info(f"Ê∫ñÂÇôÊî∂ÈõÜ {len(all_stocks)} ÊîØËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô")
        return all_stocks
    
    def fetch_minute_data(self, symbol: str, start_date: str, end_date: str) -> pd.DataFrame:
        """Áç≤ÂèñÂñÆ‰∏ÄËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô"""
        try:
            if not self.api:
                logger.error("‚ùå Shioaji API Êú™ÁôªÂÖ•")
                return pd.DataFrame()
            
            logger.info(f"üì° Ë´ãÊ±ÇÂàÜÈêòÁ∑öË≥áÊñô: {symbol} ({start_date} ~ {end_date})")
            
            # ÂèñÂæóËÇ°Á•®ÂêàÁ¥Ñ (Âõ†ÁÇ∫Ë®≠ÂÆö fetch_contract=FalseÔºåÈúÄË¶ÅÊâãÂãïÁç≤Âèñ)
            try:
                # Ê™¢Êü•ÊòØÂê¶Â∑≤Êúâ Contracts Â±¨ÊÄß
                if hasattr(self.api, 'Contracts') and hasattr(self.api.Contracts, 'Stocks'):
                    contract = self.api.Contracts.Stocks[symbol]
                    logger.debug(f"‚úÖ ‰ΩøÁî®Â∑≤ËºâÂÖ•ÁöÑ {symbol} ÂêàÁ¥Ñ")
                else:
                    raise AttributeError("Contracts Â±¨ÊÄß‰∏çÂ≠òÂú®")
            except (KeyError, AttributeError):
                # Â¶ÇÊûúÂêàÁ¥Ñ‰∏çÂ≠òÂú®Êàñ Contracts Â±¨ÊÄß‰∏çÂ≠òÂú®ÔºåÊâãÂãïÁç≤ÂèñÂêàÁ¥ÑË≥áÊñô
                logger.info(f"üîÑ ÊâãÂãïÁç≤Âèñ {symbol} ÂêàÁ¥ÑË≥áÊñô...")
                try:
                    # Áç≤ÂèñËÇ°Á•®ÂêàÁ¥Ñ
                    contracts = self.api.fetch_contracts(contract_download=True)
                    
                    # ÂÜçÊ¨°ÂòóË©¶Ë®™ÂïèÂêàÁ¥Ñ
                    if hasattr(self.api, 'Contracts') and hasattr(self.api.Contracts, 'Stocks'):
                        contract = self.api.Contracts.Stocks[symbol]
                        logger.info(f"‚úÖ ÊàêÂäüÁç≤Âèñ {symbol} ÂêàÁ¥Ñ")
                    else:
                        logger.error(f"‚ùå Áç≤ÂèñÂêàÁ¥ÑÂæå‰ªçÁÑ°Ê≥ïË®™Âïè Contracts.Stocks")
                        return pd.DataFrame()
                except Exception as e:
                    logger.error(f"‚ùå ÁÑ°Ê≥ïÁç≤Âèñ {symbol} ÂêàÁ¥Ñ: {e}")
                    return pd.DataFrame()
            
            # ÂèñÂæóKÁ∑öË≥áÊñô
            kbars = self.api.kbars(
                contract=contract,
                start=start_date,
                end=end_date,
                timeout=30000
            )
            
            if kbars and hasattr(kbars, '__dict__'):
                # ËΩâÊèõÁÇ∫DataFrame (‰øÆÂæ©ÁâàÊú¨)
                df = pd.DataFrame({**kbars})
                
                if not df.empty:
                    # Ê∑ªÂä†symbolÊ¨Ñ‰Ωç
                    df['symbol'] = symbol
                    
                    # ËΩâÊèõÊôÇÈñìÊ†ºÂºè
                    if 'ts' in df.columns:
                        df['ts'] = pd.to_datetime(df['ts'])
                    
                    # ÈáçÊñ∞ÊéíÂ∫èÊ¨Ñ‰Ωç
                    columns_order = ['symbol', 'ts', 'Open', 'High', 'Low', 'Close', 'Volume']
                    available_columns = [col for col in columns_order if col in df.columns]
                    df = df[available_columns]
                    
                    # È°ØÁ§∫ÊµÅÈáèÁõ£ÊéßÁãÄÊ≥Å (ÊØèÊ¨°Áç≤ÂèñË≥áÊñôÂæåÈÉΩÈ°ØÁ§∫)
                    if self.flow_monitor:
                        logger.info(f"üìä {symbol} Ë≥áÊñôÁç≤ÂèñÂæåÊµÅÈáèÁãÄÊ≥Å:")
                        self.flow_monitor.show_status()
                    
                    logger.info(f"‚úÖ ÊàêÂäüÁç≤Âèñ {len(df)} Á≠ÜÂàÜÈêòÁ∑öË≥áÊñô: {symbol}")
                    return df
                else:
                    logger.warning(f"‚ö†Ô∏è  {symbol} ÁÑ°ÂàÜÈêòÁ∑öË≥áÊñô")
                    return pd.DataFrame()
            else:
                logger.warning(f"‚ö†Ô∏è  {symbol} API ÂõûÂÇ≥Á©∫Ë≥áÊñô")
                return pd.DataFrame()
                
        except Exception as e:
            logger.error(f"‚ùå Áç≤Âèñ {symbol} ÂàÜÈêòÁ∑öË≥áÊñôÂ§±Êïó: {e}")
            return pd.DataFrame()
    
    def aggregate_to_5min(self, df: pd.DataFrame) -> pd.DataFrame:
        """Â∞á1ÂàÜÈêòË≥áÊñôËÅöÂêàÁÇ∫5ÂàÜÈêò"""
        if df.empty:
            return df
        
        try:
            # Ë®≠ÂÆöÊôÇÈñìÁ¥¢Âºï
            df_copy = df.copy()
            df_copy.set_index('ts', inplace=True)
            
            # 5ÂàÜÈêòËÅöÂêà
            agg_dict = {
                'Open': 'first',
                'High': 'max',
                'Low': 'min',
                'Close': 'last',
                'Volume': 'sum'
            }
            
            # ‰ΩøÁî® '5min' ËÄå‰∏çÊòØ '5T'
            df_5min = df_copy.resample('5min').agg(agg_dict)
            
            # ÁßªÈô§Á©∫ÂÄºË°å
            df_5min = df_5min.dropna()
            
            # ÈáçÁΩÆÁ¥¢Âºï
            df_5min.reset_index(inplace=True)
            
            # Ê∑ªÂä†symbolÊ¨Ñ‰Ωç
            if 'symbol' in df.columns:
                df_5min['symbol'] = df['symbol'].iloc[0]
            
            # Ë®àÁÆóVWAP
            if 'Volume' in df_5min.columns and df_5min['Volume'].sum() > 0:
                df_5min['vwap'] = (df_5min['High'] + df_5min['Low'] + df_5min['Close']) / 3
            else:
                df_5min['vwap'] = df_5min['Close']
            
            logger.info(f"üìä ËÅöÂêàÁÇ∫ {len(df_5min)} Á≠Ü5ÂàÜÈêòË≥áÊñô")
            return df_5min
            
        except Exception as e:
            logger.error(f"‚ùå ËÅöÂêà5ÂàÜÈêòË≥áÊñôÂ§±Êïó: {e}")
            return pd.DataFrame()
    
    def format_for_candlesticks_min(self, df_5min: pd.DataFrame, symbol: str) -> pd.DataFrame:
        """Â∞á5ÂàÜÈêòË≥áÊñôÊ†ºÂºèÂåñÁÇ∫ candlesticks_min Ë≥áÊñôË°®Ê†ºÂºè"""
        try:
            # Ê™¢Êü•Ëº∏ÂÖ•Ë≥áÊñô
            if df_5min.empty:
                logger.error("‚ùå Ëº∏ÂÖ•ÁöÑ5ÂàÜÈêòË≥áÊñôÁÇ∫Á©∫")
                return pd.DataFrame()
            
            if 'ts' not in df_5min.columns:
                logger.error(f"‚ùå Ëº∏ÂÖ•Ë≥áÊñôÁº∫Â∞ë 'ts' Ê¨Ñ‰ΩçÔºåÁèæÊúâÊ¨Ñ‰Ωç: {list(df_5min.columns)}")
                return pd.DataFrame()
            
            logger.info(f"üîß ÈñãÂßãÊ†ºÂºèÂåñ {len(df_5min)} Á≠Ü5ÂàÜÈêòË≥áÊñô...")
            logger.info(f"üìã Ëº∏ÂÖ•Ê¨Ñ‰Ωç: {list(df_5min.columns)}")
            
            # Âª∫Á´ãÊñ∞ÁöÑ DataFrameÔºåÈÄê‰∏ÄË®≠ÂÆöÊ¨Ñ‰Ωç
            df_formatted = pd.DataFrame(index=df_5min.index)
            
            # Ë®≠ÂÆöÂõ∫ÂÆöÂÄºÊ¨Ñ‰Ωç
            df_formatted['market'] = 'TW'
            df_formatted['symbol'] = symbol
            df_formatted['interval'] = '5min'
            
            # Ë®≠ÂÆöÊôÇÈñìÊà≥Ë®ò
            df_formatted['timestamp'] = df_5min['ts'].dt.strftime('%Y-%m-%d %H:%M:%S')
            
            # Ë®≠ÂÆöÂÉπÊ†ºÂíåÊàê‰∫§ÈáèÊ¨Ñ‰Ωç - Áõ¥Êé•‰ΩøÁî®Ê¨Ñ‰ΩçÂêçÁ®±
            price_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
            target_columns = ['open', 'high', 'low', 'close', 'volume']
            
            for price_col, target_col in zip(price_columns, target_columns):
                if price_col in df_5min.columns:
                    df_formatted[target_col] = df_5min[price_col]
                    logger.info(f"‚úÖ Ë®≠ÂÆö {target_col}: {price_col}")
                else:
                    df_formatted[target_col] = 0.0
                    logger.warning(f"‚ö†Ô∏è  Ê¨Ñ‰Ωç {price_col} ‰∏çÂ≠òÂú®ÔºåË®≠ÁÇ∫ 0")
            
            # Ê™¢Êü•ÁµêÊûú
            logger.info(f"üìä Ê†ºÂºèÂåñÁµêÊûú:")
            logger.info(f"   market: {df_formatted['market'].iloc[0] if len(df_formatted) > 0 else 'N/A'}")
            logger.info(f"   symbol: {df_formatted['symbol'].iloc[0] if len(df_formatted) > 0 else 'N/A'}")
            logger.info(f"   timestamp ÁØÑ‰æã: {df_formatted['timestamp'].iloc[0] if len(df_formatted) > 0 else 'N/A'}")
            logger.info(f"   open ÁØÑ‰æã: {df_formatted['open'].iloc[0] if len(df_formatted) > 0 else 'N/A'}")
            
            # ÊúÄÁµÇÊ™¢Êü•
            if df_formatted.empty:
                logger.error("‚ùå Ê†ºÂºèÂåñÂæåË≥áÊñôÁÇ∫Á©∫")
                return pd.DataFrame()
            
            # Ê™¢Êü•ÂøÖË¶ÅÊ¨Ñ‰ΩçÊòØÂê¶ÊúâÂÄº
            required_fields = ['market', 'symbol', 'timestamp']
            for field in required_fields:
                if df_formatted[field].isnull().any():
                    logger.error(f"‚ùå ÂøÖË¶ÅÊ¨Ñ‰Ωç {field} ÂåÖÂê´Á©∫ÂÄº")
                    return pd.DataFrame()
            
            logger.info(f"‚úÖ ÊàêÂäüÊ†ºÂºèÂåñ {len(df_formatted)} Á≠ÜË≥áÊñôÁÇ∫ candlesticks_min Ê†ºÂºè")
            return df_formatted
            
        except Exception as e:
            logger.error(f"‚ùå Ê†ºÂºèÂåñ candlesticks_min Ë≥áÊñôÂ§±Êïó: {e}")
            import traceback
            traceback.print_exc()
            return pd.DataFrame()
    
    def check_minute_data_exists(self, symbol: str, start_date: str, end_date: str) -> bool:
        """Ê™¢Êü•ÂàÜÈêòÁ∑öË≥áÊñôÊòØÂê¶Â∑≤Â≠òÂú®ÊñºË≥áÊñôÂ∫´‰∏≠"""
        try:
            # Êü•Ë©¢Ë≥áÊñôÂ∫´‰∏≠ÊòØÂê¶Â∑≤ÊúâË©≤ËÇ°Á•®Âú®ÊåáÂÆöÊôÇÈñìÁØÑÂúçÁöÑË≥áÊñô
            query_sql = """
            SELECT COUNT(*) as count 
            FROM candlesticks_min 
            WHERE symbol = ? AND timestamp BETWEEN ? AND ?
            """
            
            # ËΩâÊèõÊó•ÊúüÊ†ºÂºè
            start_timestamp = f"{start_date} 00:00:00"
            end_timestamp = f"{end_date} 23:59:59"
            
            df_check = self.query_df(query_sql, (symbol, start_timestamp, end_timestamp))
            
            if not df_check.empty and df_check['count'].iloc[0] > 0:
                record_count = df_check['count'].iloc[0]
                logger.info(f"üìä {symbol} Â∑≤Êúâ {record_count} Á≠ÜÂàÜÈêòÁ∑öË≥áÊñôÂú® {start_date} ~ {end_date}")
                
                # Â¶ÇÊûúË≥áÊñôÈáèÂêàÁêÜÔºàËá≥Â∞ë100Á≠ÜÔºâÔºåË™çÁÇ∫Â∑≤Â≠òÂú®
                if record_count >= 100:
                    return True
                else:
                    logger.info(f"‚ö†Ô∏è {symbol} Ë≥áÊñôÈáèËºÉÂ∞ë ({record_count} Á≠Ü)ÔºåÈáçÊñ∞‰∏ãËºâ")
                    return False
            else:
                return False
                
        except Exception as e:
            logger.debug(f"Ê™¢Êü• {symbol} ÂàÜÈêòÁ∑öË≥áÊñôÊôÇÁôºÁîüÈåØË™§: {e}")
            return False

    def collect_stock_minute_data(self, symbol: str, start_date: str = "2020-03-02", end_date: str = "2025-07-08"):
        """Êî∂ÈõÜÂñÆ‰∏ÄËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô"""
        logger.info(f"üéØ ÈñãÂßãÊî∂ÈõÜ {symbol} ÁöÑÂàÜÈêòÁ∑öË≥áÊñô...")
        
        # È°ØÁ§∫ÈñãÂßãËôïÁêÜÂâçÁöÑÊµÅÈáèÁãÄÊ≥Å
        if self.flow_monitor:
            logger.info(f"üìä ÈñãÂßãËôïÁêÜ {symbol} ÂâçÁöÑË©≥Á¥∞ÊµÅÈáèÁãÄÊ≥Å:")
            self.flow_monitor.show_status()
        
        # Ê™¢Êü•Ë≥áÊñôÊòØÂê¶Â∑≤Â≠òÂú®
        if self.check_minute_data_exists(symbol, start_date, end_date):
            logger.info(f"‚è≠Ô∏è {symbol} ÂàÜÈêòÁ∑öË≥áÊñôÂ∑≤Â≠òÂú®ÔºåÁï•ÈÅé‰∏ãËºâ")
            # Âç≥‰ΩøÁï•ÈÅé‰πüÈ°ØÁ§∫ÊµÅÈáèÁãÄÊ≥Å
            if self.flow_monitor:
                logger.info(f"üìä Áï•ÈÅé {symbol} ÂæåÁöÑÊµÅÈáèÁãÄÊ≥Å:")
                self.flow_monitor.show_status()
            return 0  # Ê®ôË®òÁÇ∫Â∑≤Â≠òÂú®
        
        try:
            # Áç≤Âèñ1ÂàÜÈêòË≥áÊñô
            df_1min = self.fetch_minute_data(symbol, start_date, end_date)
            
            if not df_1min.empty:
                # ËÅöÂêàÁÇ∫5ÂàÜÈêò
                df_5min = self.aggregate_to_5min(df_1min)
                
                if not df_5min.empty:
                    # ËΩâÊèõÁÇ∫ candlesticks_min Ê†ºÂºè‰∏¶ÂÑ≤Â≠ò
                    df_formatted = self.format_for_candlesticks_min(df_5min, symbol)
                    
                    if not df_formatted.empty:
                        # Ê™¢Êü•ÊòØÂê¶ÊúâÈáçË§áË≥áÊñôÔºåÂ¶ÇÊûúÊúâÂâáÂÖàÂà™Èô§
                        try:
                            from market_data_collector.utils.db import execute_sql
                            
                            # Âà™Èô§Ë©≤ËÇ°Á•®Âú®Áõ∏ÂêåÊôÇÈñìÁØÑÂúçÁöÑËàäË≥áÊñô
                            min_timestamp = df_formatted['timestamp'].min()
                            max_timestamp = df_formatted['timestamp'].max()
                            
                            delete_sql = """
                            DELETE FROM candlesticks_min 
                            WHERE symbol = ? AND timestamp BETWEEN ? AND ?
                            """
                            execute_sql(delete_sql, (symbol, min_timestamp, max_timestamp))
                            logger.info(f"üóëÔ∏è Ê∏ÖÈô§ {symbol} Âú® {min_timestamp} ~ {max_timestamp} ÁöÑËàäË≥áÊñô")
                            
                        except ImportError:
                            logger.warning("‚ö†Ô∏è ÁÑ°Ê≥ïÂåØÂÖ• execute_sqlÔºåË∑≥ÈÅéÊ∏ÖÈô§ËàäË≥áÊñô")
                        except Exception as e:
                            logger.warning(f"‚ö†Ô∏è Ê∏ÖÈô§ËàäË≥áÊñôÂ§±Êïó: {e}")
                        
                        # ÊèíÂÖ•Êñ∞Ë≥áÊñô
                        self.insert_df('candlesticks_min', df_formatted, if_exists='append')
                        logger.info(f"üíæ ÊàêÂäüÂÑ≤Â≠ò {len(df_formatted)} Á≠Ü5ÂàÜÈêòË≥áÊñôÂà∞ candlesticks_min: {symbol}")
                        
                        # È°ØÁ§∫Ë≥áÊñôÂÑ≤Â≠òÂæåÁöÑÊµÅÈáèÁãÄÊ≥Å
                        if self.flow_monitor:
                            logger.info(f"üìä {symbol} Ë≥áÊñôÂÑ≤Â≠òÂæåÁöÑÊµÅÈáèÁãÄÊ≥Å:")
                            self.flow_monitor.show_status()
                        
                        return len(df_formatted)
                    else:
                        logger.error(f"‚ùå {symbol} Ê†ºÂºèÂåñÂæåË≥áÊñôÁÇ∫Á©∫")
                        return 0
                else:
                    logger.warning(f"‚ö†Ô∏è  {symbol} ËÅöÂêà5ÂàÜÈêòË≥áÊñôÂ§±Êïó")
                    return 0
            else:
                logger.warning(f"‚ö†Ô∏è  {symbol} ÁÑ°1ÂàÜÈêòË≥áÊñô")
                return 0
                
        except Exception as e:
            logger.error(f"‚ùå ËôïÁêÜ {symbol} ÂàÜÈêòÁ∑öË≥áÊñôÂ§±Êïó: {e}")
            
            # Âç≥‰ΩøÂ§±Êïó‰πüÈ°ØÁ§∫ÊµÅÈáèÁãÄÊ≥Å
            if self.flow_monitor:
                logger.info(f"üìä {symbol} ËôïÁêÜÂ§±ÊïóÂæåÁöÑÊµÅÈáèÁãÄÊ≥Å:")
                self.flow_monitor.show_status()
            
            return -1
    
    def collect_all_minute_data(self, symbols: Optional[List[str]] = None,
                               start_date: str = "2020-03-02",
                               end_date: str = "2025-07-08",
                               test_mode: bool = True):
        """Êî∂ÈõÜÊâÄÊúâËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô"""
        if symbols is None:
            symbols = self.get_stock_list()
        
        if test_mode:
            # Ê∏¨Ë©¶Ê®°ÂºèÔºöÂè™Êî∂ÈõÜÂâç3ÊîØËÇ°Á•®Ôºå‰ΩøÁî®Áü≠ÊôÇÈñìÁØÑÂúçÁØÄÁúÅÊµÅÈáè
            symbols = symbols[:3]
            start_date = "2024-12-01"  # Ê∏¨Ë©¶Ê®°Âºè‰ΩøÁî®Áü≠ÊôÇÈñìÁØÑÂúç
            end_date = "2024-12-31"
            logger.info(f"üß™ Ê∏¨Ë©¶Ê®°ÂºèÔºöÊî∂ÈõÜ {symbols} ÁöÑÂàÜÈêòÁ∑öË≥áÊñô")
            logger.info(f"üß™ Ê∏¨Ë©¶Ê®°Âºè‰ΩøÁî®Áü≠ÊôÇÈñìÁØÑÂúçÁØÄÁúÅÊµÅÈáè: {start_date} ~ {end_date}")
        
        logger.info(f"üìä ÈñãÂßãÊî∂ÈõÜ {len(symbols)} ÊîØËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô...")
        logger.info(f"üìÖ Êó•ÊúüÁØÑÂúç: {start_date} ~ {end_date}")
        
        # ÁôªÂÖ•API
        if not self.login_shioaji():
            logger.error("‚ùå ÁÑ°Ê≥ïÁôªÂÖ• ShioajiÔºåÂÅúÊ≠¢Âü∑Ë°å")
            return
        
        # Ë®≠ÂÆöÊµÅÈáèÁõ£Êéß (ÂøÖÈ†àÂú®ÁôªÂÖ•ÂæåË®≠ÁΩÆ)
        self.setup_flow_monitor()
        
        # È°ØÁ§∫ÂàùÂßãÊµÅÈáèÁãÄÊ≥Å
        if self.flow_monitor:
            logger.info("üìä ÂàùÂßãÊµÅÈáèÁãÄÊ≥Å:")
            self.flow_monitor.show_status()
        
        results = {}
        
        try:
            for i, symbol in enumerate(symbols):
                logger.info(f"üìà ËôïÁêÜÈÄ≤Â∫¶: {i+1}/{len(symbols)} - {symbol}")
                
                # ÊØèÊîØËÇ°Á•®ËôïÁêÜÂâçÈ°ØÁ§∫ÊµÅÈáèÁãÄÊ≥Å
                if self.flow_monitor:
                    logger.info(f"üìä ËôïÁêÜ {symbol} ÂâçÁöÑÊµÅÈáèÁãÄÊ≥Å:")
                    usage_info = self.flow_monitor.show_status()
                    
                    # Ê™¢Êü•ÊµÅÈáèÈôêÂà∂
                    if usage_info and usage_info.get('percentage', 0) >= 95.0:
                        logger.warning("üö® ÊµÅÈáè‰ΩøÁî®ÁéáÂ∑≤ÈÅî 95%ÔºåÂÅúÊ≠¢Êî∂ÈõÜ‰ª•ÈÅøÂÖçË∂ÖÈôê")
                        break
                
                # Êî∂ÈõÜË©≤ËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô
                result = self.collect_stock_minute_data(symbol, start_date, end_date)
                results[symbol] = result
                
                # ÊØèÊîØËÇ°Á•®ËôïÁêÜÂæåÈ°ØÁ§∫ÊµÅÈáèÁãÄÊ≥Å
                if self.flow_monitor:
                    logger.info(f"üìä ËôïÁêÜ {symbol} ÂæåÁöÑÊµÅÈáèÁãÄÊ≥Å:")
                    usage_info = self.flow_monitor.show_status()
                    
                    # Â¶ÇÊûúÊµÅÈáè‰ΩøÁî®ÁéáË∂ÖÈÅé 90%ÔºåÂ¢ûÂä†‰ºëÊÅØÊôÇÈñì
                    if usage_info and usage_info.get('percentage', 0) > 90:
                        logger.warning("‚ö†Ô∏è ÊµÅÈáè‰ΩøÁî®ÁéáË∂ÖÈÅé 90%ÔºåÂ¢ûÂä†‰ºëÊÅØÊôÇÈñì")
                        time.sleep(3)
                
                # ÊØèÊîØËÇ°Á•®Âæå‰ºëÊÅØ‰∏Ä‰∏ãÔºåÈÅøÂÖçAPIÈôêÂà∂
                time.sleep(0.75)
                
        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è  Êî∂Âà∞‰∏≠Êñ∑‰ø°ËôüÔºåÊ≠£Âú®ÂÅúÊ≠¢...")
            raise
        
        except Exception as e:
            logger.error(f"‚ùå ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÈÅéÁ®ãÁôºÁîüÈåØË™§: {e}")
            raise
        
        finally:
            # È°ØÁ§∫ÊúÄÁµÇÊµÅÈáè‰ΩøÁî®ÁãÄÊ≥Å (Âú®ÁôªÂá∫Ââç)
            if self.flow_monitor and self.api:
                logger.info("=" * 50)
                logger.info("üìä ÊúÄÁµÇÊµÅÈáè‰ΩøÁî®ÁãÄÊ≥Å")
                logger.info("=" * 50)
                try:
                    final_usage = self.flow_monitor.show_status()
                    if final_usage:
                        bytes_used_mb = final_usage['bytes_used'] / (1024 * 1024)
                        limit_mb = final_usage['limit_bytes'] / (1024 * 1024)
                        percentage = final_usage['percentage']
                        logger.info(f"üèÅ ÊµÅÈáè‰ΩøÁî®Á∏ΩÁµê: {bytes_used_mb:.1f}MB/{limit_mb:.1f}MB Â∑≤‰ΩøÁî®{percentage:.2f}%")
                    else:
                        logger.warning("‚ö†Ô∏è ÁÑ°Ê≥ïÁç≤ÂèñÊúÄÁµÇÊµÅÈáè‰ΩøÁî®ÁãÄÊ≥Å")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Áç≤ÂèñÊúÄÁµÇÊµÅÈáèÁãÄÊ≥ÅÊôÇÁôºÁîüÈåØË™§: {e}")
                logger.info("=" * 50)
            
            # ÁôªÂá∫API
            if self.api:
                try:
                    self.api.logout()
                    logger.info("üîì Shioaji Â∑≤ÁôªÂá∫")
                except:
                    pass
            
            # È°ØÁ§∫Êî∂ÈõÜÁµêÊûúÁµ±Ë®à
            self.show_minute_collection_summary(results)
    
    def show_minute_collection_summary(self, results: Dict):
        """È°ØÁ§∫ÂàÜÈêòÁ∑öÊî∂ÈõÜÁµêÊûúÁµ±Ë®à"""
        logger.info("=" * 50)
        logger.info("üìä Shioaji ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÂÆåÊàêÁµ±Ë®à")
        logger.info("=" * 50)
        
        total_new_records = 0
        success_count = 0
        skipped_count = 0
        failed_count = 0
        
        for symbol, result in results.items():
            if result > 0:
                total_new_records += result
                success_count += 1
                logger.info(f"‚úÖ {symbol}: {result:6} Á≠ÜÊñ∞5ÂàÜÈêòË≥áÊñô")
            elif result == 0:
                skipped_count += 1
                logger.info(f"‚è≠Ô∏è {symbol}: Â∑≤Â≠òÂú®ÔºåÁï•ÈÅé")
            else:
                failed_count += 1
                logger.info(f"‚ùå {symbol}: Â§±Êïó")
        
        logger.info("=" * 50)
        logger.info(f"üìà Êñ∞‰∏ãËºâ: {success_count} ÊîØËÇ°Á•®")
        logger.info(f"‚è≠Ô∏è Â∑≤Â≠òÂú®: {skipped_count} ÊîØËÇ°Á•®")
        logger.info(f"‚ùå Â§±Êïó: {failed_count} ÊîØËÇ°Á•®")
        logger.info(f"üìä Êñ∞Â¢ûË≥áÊñô: {total_new_records} Á≠Ü5ÂàÜÈêòË≥áÊñô")
        logger.info("=" * 50)


def main():
    """‰∏ªÂáΩÊï∏"""
    print("=" * 50)
    print("üìà Shioaji ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÂô® (Êô∫ËÉΩÁâà)")
    print("=" * 50)
    print("Êñ∞ÂäüËÉΩÔºö")
    print("‚Ä¢ Èò≤ÈáçË§á‰∏ãËºâÊ©üÂà∂ - Ëá™ÂãïÊ™¢Êü•Â∑≤Â≠òÂú®Ë≥áÊñô")
    print("‚Ä¢ ÂÆòÊñπÊµÅÈáèÁõ£Êéß - ‰ΩøÁî® api.usage() ÊñπÊ≥ï")
    print("‚Ä¢ Êô∫ËÉΩË≠¶ÂëäËàáËá™ÂãïÂÅúÊ≠¢ (95% ÊµÅÈáèÈôêÂà∂)")
    print("‚Ä¢ ÊµÅÈáèÁØÄÁúÅÁôªÂÖ• - fetch_contract=False")
    print("‚Ä¢ Ë©≥Á¥∞ÁöÑ‰∏ãËºâ/Áï•ÈÅéÁãÄÊÖãÊó•Ë™å")
    print("‚Ä¢ ÊúÄÁµÇÊµÅÈáè‰ΩøÁî®ÁãÄÊ≥ÅÂ†±Âëä")
    print("Êî∂ÈõÜÂÖßÂÆπÔºö")
    print("‚Ä¢ 1ÂàÜÈêòKÁ∑öË≥áÊñô (ÂæûShioaji API)")
    print("‚Ä¢ ËÅöÂêàÁÇ∫5ÂàÜÈêòKÁ∑öË≥áÊñô")
    print("‚Ä¢ ÂÑ≤Â≠òÂà∞ candlesticks_min Ë≥áÊñôË°®")
    print("‚Ä¢ Êó•ÊúüÁØÑÂúç: 2020-03-02 ~ 2025-07-08 (Ê≠£ÂºèÊ®°Âºè)")
    print("‚Ä¢ Ê∏¨Ë©¶Ê®°Âºè: 2024-12-01 ~ 2024-12-31 (ÁØÄÁúÅÊµÅÈáè)")
    print("=" * 50)
    
    try:
        collector = ShioajiDataCollector()
        
        # Ë©¢ÂïèÁî®Êà∂ÊòØÂê¶Ë¶ÅÊ∏¨Ë©¶Ê®°Âºè
        choice = input("ÈÅ∏ÊìáÊ®°Âºè (1=Ê∏¨Ë©¶Ê®°ÂºèÊî∂ÈõÜ3ÊîØËÇ°Á•®, 2=ÂÆåÊï¥Ê®°ÂºèÊî∂ÈõÜ180ÊîØËÇ°Á•®): ").strip()
        
        if choice == "1":
            print("üß™ Ê∏¨Ë©¶Ê®°ÂºèÔºöÊî∂ÈõÜÂâç3ÊîØËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô")
            collector.collect_all_minute_data(test_mode=True)
        elif choice == "2":
            print("üöÄ ÂÆåÊï¥Ê®°ÂºèÔºöÊî∂ÈõÜÂÖ®ÈÉ®180ÊîØËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô")
            collector.collect_all_minute_data(test_mode=False)
        else:
            print("üß™ È†êË®≠Ê∏¨Ë©¶Ê®°ÂºèÔºöÊî∂ÈõÜÂâç3ÊîØËÇ°Á•®ÁöÑÂàÜÈêòÁ∑öË≥áÊñô")
            collector.collect_all_minute_data(test_mode=True)
        
        print("‚úÖ Shioaji ÂàÜÈêòÁ∑öË≥áÊñôÊî∂ÈõÜÂÆåÊàêÔºÅ")
        
    except Exception as e:
        logger.error(f"‚ùå Âü∑Ë°åÂ§±Êïó: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()